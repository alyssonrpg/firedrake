unit TestFD.Compiler.Lexer.Pascal;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, System.SysUtils, System.Classes,
  FD.Compiler.Lexer, FD.Compiler.Lexer.Pascal, TestFD.Compiler.Lexer, FD.Compiler.Environment,
  FD.Compiler.Lexer.Tokens, System.Diagnostics;

type
  // Test methods for class TPascalLexer

  TestTPascalLexer = class(TestTLexer)
  protected
    FEnv: TCompilerEnvironment;
    FPascalLexer: TPascalLexer;

    procedure SetupEnv(CaseID: String); override;
    procedure SetupPascalTest(CaseID: String); virtual;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestVeryBasic1;
    procedure TestVeryBasic2;

    procedure TestBasicTokenTypes1;
    procedure TestLongFiles;
    procedure TestStringLexing;
  end;

implementation

procedure TestTPascalLexer.SetUp;
begin

end;

procedure TestTPascalLexer.SetupEnv(CaseID: String);
begin
  inherited SetupEnv(CaseID);

  if FPascalLexer <> nil then
  begin
    FPascalLexer.DisposeOf;
    FPascalLexer := nil;
  end;

  if FEnv <> nil then
  begin
    FEnv.DisposeOf;
    FEnv := nil;
  end;

  FEnv := TCompilerEnvironment.Create;
  FEnv.BasePath := FTestDir;

  FPascalLexer := TPascalLexer.Create(FEnv);
  FLexer := FPascalLexer;
end;

procedure TestTPascalLexer.SetupPascalTest(CaseID: String);
begin
  Self.SetupEnv('Lexer/pascal/' + CaseID + PathDelim);
end;

procedure TestTPascalLexer.TearDown;
begin
  if FEnv <> nil then
  begin
    FEnv.DisposeOf;
    FEnv := nil;
  end;

  if FPascalLexer <> nil then
  begin
    FPascalLexer.Free;
    FPascalLexer := nil;
  end;
end;

procedure TestTPascalLexer.TestBasicTokenTypes1;
begin
  Self.SetupPascalTest('BasicTokenTypes1');
  FPascalLexer.OpenFile('content.txt');
  Assert(FPascalLexer.GetNextToken().IsKeyword('unit'));
  Assert(FPascalLexer.GetNextToken().IsOperator('+'));
  Assert(FPascalLexer.GetNextToken().IsOperator('-'));
  Assert(FPascalLexer.GetNextToken().IsOperator('+'));
  Assert(FPascalLexer.GetNextToken().IsOperator('*'));
  Assert(FPascalLexer.GetNextToken().IsWhiteSpace);
  Assert(FPascalLexer.GetNextToken().IsIdentifier('foo'));
  Assert(FPascalLexer.GetNextToken().IsOperator('.'));
  Assert(FPascalLexer.GetNextToken().IsIdentifier('bar'));
  Assert(FPascalLexer.GetNextToken().IsWhiteSpace);
  Assert(FPascalLexer.GetNextToken().IsIdentifier('bar25'));
  Assert(FPascalLexer.GetNextToken().IsWhiteSpace());
  Assert(FPascalLexer.GetNextToken().IsLiteralInteger(25));
  Assert(FPascalLexer.GetNextToken().IsWhiteSpace());
  Assert(FPascalLexer.GetNextToken().IsMalformedToken('25bar'));
  Assert(FPascalLexer.GetNextToken().IsWhiteSpace());
  Assert(FPascalLexer.GetNextToken().IsLiteralFloat(25.3));
  Assert(FPascalLexer.GetNextToken().IsWhiteSpace());
  Assert(FPascalLexer.GetNextToken().IsLiteralFloat(25e3));
  Assert(FPascalLexer.GetNextToken().IsWhiteSpace());
  Assert(FPascalLexer.GetNextToken().IsLiteralFloat(1.5e3));
  Assert(FPascalLexer.GetNextToken().IsWhiteSpace());
  Assert(FPascalLexer.GetNextToken().IsLiteralFloat(0.5e-3));
  Assert(FPascalLexer.GetNextToken().IsWhiteSpace());
  Assert(FPascalLexer.GetNextToken().IsLiteralInteger(25));
  Assert(FPascalLexer.GetNextToken().IsOperator('.'));
  Assert(FPascalLexer.GetNextToken().IsIdentifier('bar'));
  Assert(FPascalLexer.GetNextToken().IsWhiteSpace());
  Assert(FPascalLexer.GetNextToken().IsMalformedToken('25.5a'));
  Assert(FPascalLexer.GetNextToken().IsWhiteSpace());
  Assert(FPascalLexer.GetNextToken().IsMalformedToken('25e.6'));
  Assert(FPascalLexer.GetNextToken().IsWhiteSpace());
  Assert(FPascalLexer.GetNextToken().IsMalformedToken('25e-a'));
  Assert(FPascalLexer.GetNextToken().IsWhiteSpace());
  Assert(FPascalLexer.GetNextToken().IsLiteralFloat(25.7e-20));
  Assert(FPascalLexer.GetNextToken().IsEOF);
end;

procedure TestTPascalLexer.TestLongFiles;
var
  Tok: TToken;
  SW: TStopWatch;
begin
  Self.SetupPascalTest('LongFiles');

  SW := TStopwatch.StartNew;
  FPascalLexer.OpenFile('LongContentFile.pas');

  SW.Stop;

  if SW.Elapsed.TotalMilliseconds = -5 then
    Abort; // Will never reach. Just a easy way to add breakpoint and watch "SW.Elapsed.TotalMilliseconds" value

  SW := TStopwatch.StartNew;

  while not FPascalLexer.EOF do
    Tok := FPascalLexer.GetNextToken();

  SW.Stop;

  if SW.Elapsed.TotalMilliseconds = -5 then
    Abort; // Will never reach. Just a easy way to add breakpoint and watch "SW.Elapsed.TotalMilliseconds" value
end;

procedure TestTPascalLexer.TestStringLexing;
begin
  Self.SetupPascalTest('StringLexing');
  FPascalLexer.OpenFile('content.txt');
  Assert(FPascalLexer.GetNextToken().IsKeyword('if'));
  Assert(FPascalLexer.GetNextToken().IsLiteralString('foo'));
  Assert(FPascalLexer.GetNextToken().IsOperator('='));
  Assert(FPascalLexer.GetNextToken().IsLiteralString('bar'));
  Assert(FPascalLexer.GetNextToken().IsWhiteSpace());
  Assert(FPascalLexer.GetNextToken().IsKeyword('then'));
  Assert(FPascalLexer.GetNextToken().IsWhiteSpace);
  Assert(FPascalLexer.GetNextToken().IsLiteralString(''));
  Assert(FPascalLexer.GetNextToken().IsIdentifier('foo'));
  Assert(FPascalLexer.GetNextToken().IsLiteralString('josé'));
  Assert(FPascalLexer.GetNextToken().IsWhiteSpace);
  Assert(FPascalLexer.GetNextToken().IsIdentifier('foo'));
  Assert(FPascalLexer.GetNextToken().IsLiteralString('josé''maria'));
  Assert(FPascalLexer.GetNextToken().IsWhiteSpace);
  Assert(FPascalLexer.GetNextToken().IsLiteralString('josé''maria''ana''foo''bar'));
  Assert(FPascalLexer.GetNextToken().IsWhiteSpace);

  // Malformed strings
  Assert(FPascalLexer.GetNextToken().IsMalformedToken('''abacate', PASCAL_TOKEN_MALFORMED_UNTERMINATED_STRING));
  Assert(FPascalLexer.GetNextToken().IsWhiteSpace);
  Assert(FPascalLexer.GetNextToken().IsMalformedToken('''abacate''''', PASCAL_TOKEN_MALFORMED_UNTERMINATED_STRING));
  Assert(FPascalLexer.GetNextToken().IsWhiteSpace);
  Assert(FPascalLexer.GetNextToken().IsMalformedToken('''abacate''''terra', PASCAL_TOKEN_MALFORMED_UNTERMINATED_STRING));
  Assert(FPascalLexer.GetNextToken().IsWhiteSpace);
  Assert(FPascalLexer.GetNextToken().IsMalformedToken('''josé''''maria''''ana''''foo''''bar''''', PASCAL_TOKEN_MALFORMED_UNTERMINATED_STRING));
end;

procedure TestTPascalLexer.TestVeryBasic1;
var
  Tok: TToken;
begin
  Self.SetupPascalTest('VeryBasic1');
  FPascalLexer.OpenFile('content.txt');
  Tok := FPascalLexer.GetNextToken();

  Assert(Tok.TokenType = TTokenType.ttKeyword);
  Assert(Tok.InputString = 'unit');
  Assert(Tok.IsKeyword('unit'));
  Assert(Tok.IsKeyword('UnIt'));
  Assert(Tok.IsKeyword('UNIT'));

  Assert(FPascalLexer.GetNextToken().IsWhiteSpace);
  Assert(FPascalLexer.GetNextToken().IsIdentifier('TEST'));
  Assert(FPascalLexer.GetNextToken().IsOperator(';'));
  Assert(FPascalLexer.GetNextToken().IsEOF);
end;

procedure TestTPascalLexer.TestVeryBasic2;
var
  Tok: TToken;
begin
  Self.SetupPascalTest('VeryBasic2');
  FPascalLexer.OpenFile('content.txt');
  Tok := FPascalLexer.GetNextToken();

  Assert(Tok.TokenType = TTokenType.ttKeyword);
  Assert(Tok.InputString = 'unit');
  Assert(Tok.IsKeyword('unit'));
  Assert(Tok.IsKeyword('UnIt'));
  Assert(Tok.IsKeyword('UNIT'));

  Assert(FPascalLexer.GetNextToken().IsWhiteSpace);
  Assert(FPascalLexer.GetNextToken().IsIdentifier('TEST'));
  Assert(FPascalLexer.GetNextToken().IsOperator(';'));
  Assert(FPascalLexer.GetNextToken().IsEOF);
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTPascalLexer.Suite);
end.

